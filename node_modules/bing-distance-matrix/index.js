// Modified version of source: https://github.com/AshSat19/bing-distance-matrix
// HTTPS request is changed to HTTP request

const http = require('http');
'use strict'

class BingDistanceMatrix {
    
    BING_MAPS_API_KEY;
    
    bingMapsRequestOptions;
    bingMapQueryOpts;
    
    distanceResults;
    durationResults;
    placesCount;
    distanceMatrix;
    firstStartingPoint;
    allDuration;

    constructor(apiKey) {
        this.BING_MAPS_API_KEY = apiKey;
        
        this.bingMapsRequestOptions = {
            hostname: 'dev.virtualearth.net',
            port: 80,
            path: '/REST/v1/Routes/DistanceMatrix?key=' + apiKey,
            method: 'POST',
            headers: {'Content-Type': 'application/json'}
        };
        
        this.bingMapQueryOpts = {
            origins: [],
            destinations: [],
            travelMode: 'driving',
            timeUnit: 'second',
            distanceUnit: 'km'
        }
    
        this.distanceResults = [];
        this.durationResults = [];
        this.placesCount = 0;
        this.distanceMatrix = [];
        this.firstStartingPoint = -1;
        this.allDuration = [];
    }
  
    getDistanceMatrix = (options) => {
        
        return new Promise((resolve, reject) => {
            if (!options) {
                console.error('Please pass valid parameters');
                reject('ERROR: No parameters set');
                return;
            }

            this.bingMapQueryOpts.origins = options.destinations;
            this.bingMapQueryOpts.destinations = options.destinations;
            this.placesCount = Object.keys(this.bingMapQueryOpts.destinations).length;
            // Create one dimensional array
            this.distanceMatrix = new Array(this.placesCount);
            // Loop to create 2D array using 1D array
            for (let i = 0; i < this.placesCount; i++) {
                this.distanceMatrix[i] = new Array(this.placesCount);
            }

            // Get the index of first starting point
            this.firstStartingPoint = options.destinations.findIndex( (element) => (
                (element.latitude === options.origins[0].latitude) && 
                (element.longitude === options.origins[0].longitude)));

            if (options.travelMode) {
                this.bingMapQueryOpts.travelMode = options.travelMode;
            }
            if (options.timeUnit) {
                this.bingMapQueryOpts.timeUnit = options.timeUnit;
            }
            if (options.distanceUnit) {
                this.bingMapQueryOpts.distanceUnit = options.distanceUnit;
            }
            
            if (this.bingMapQueryOpts.origins.length <= 0) {
                console.error('Please enter atleast one origin point.');
                reject('ERROR: No Origins specified');
                return;
            }
            if (this.bingMapQueryOpts.destinations.length <= 0) {
                console.error('Please enter atleast one destination point.');
                reject('ERROR: No Destinations specified');
                return;
            }
        
            if (!this.BING_MAPS_API_KEY) {
                console.error('Please ensure that a valid Bing Maps API key is passed.');
                reject('ERROR: No API Key specified');
                return;
            }

            const bingMapReq = http
            .request(this.bingMapsRequestOptions, (res, err) => {
                if (err) {
                    console.log('An unexpected err occured');
                    reject('ERROR: ', err);
                }
                res.on('data', (d) => {
                    if (
                        JSON.parse(d).resourceSets && 
                        JSON.parse(d).resourceSets[0].resources
                    ) {
                        JSON.parse(d).resourceSets[0].resources[0].results.forEach(result => {
                            this.distanceResults.push({
                                originIndex: result.originIndex,
                                destinationIndex: result.destinationIndex,
                                distance: result.travelDistance,
                                unit: this.bingMapQueryOpts.distanceUnit
                            });
                            this.durationResults.push({
                                originIndex: result.originIndex,
                                destinationIndex: result.destinationIndex,
                                duration: result.travelDuration,
                                unit: this.bingMapQueryOpts.timeUnit
                            });
                           
                        });// end of JSON.parse.forEach

                        resolve({
                            distances: this.distanceResults, 
                            durations: this.durationResults
                        })
                        this.allDuration = this.durationResults.map(a => a.duration);
                        let k = 0;
                        for(let m = 0; m < this.placesCount; m++){
                            for(let n = 0; n < this.placesCount; n++){
                                this.distanceMatrix[m][n] = this.allDuration[k++];
                            }
                        }
                    }// end of if
                });// end of res.on()
               
            });// end of http.request()

            bingMapReq.write(JSON.stringify(this.bingMapQueryOpts))
            
            bingMapReq.on('error', (e) => {
                console.log('An unexpected error occured');
                reject('ERROR: ', e);
            });
            
            bingMapReq.end();     
        });//end of return promise
    };// end of getDistanceMatrix

    getDurationMatrix = () => {
        return this.distanceMatrix;
    }

    computeFastestRoute = () => {
        let visited = [];
        let currentLoc = this.firstStartingPoint;
        let nearestLoc;
        let nearestDist;
        let dist;

        while(visited.length < this.placesCount-1){
            nearestLoc = -1;
            nearestDist = Number.POSITIVE_INFINITY;
            for(let n = 0; n < this.placesCount; n++){
                dist = this.distanceMatrix[currentLoc][n]
                if(!visited.includes(n) && dist != 0 && dist < nearestDist){
                    nearestDist = this.distanceMatrix[currentLoc][n];
                    nearestLoc = n;
                }
            }
            visited.push(currentLoc);//0,1,3
            currentLoc = nearestLoc;//1,3,2
        }
        visited.push(nearestLoc); //last location
        console.log('Successfully connected to Bing Distance Matrix API');
        return visited;
    }
}// end of class

module.exports = BingDistanceMatrix;